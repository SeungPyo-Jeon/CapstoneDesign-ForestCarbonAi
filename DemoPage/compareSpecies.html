<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>종 비교 지도</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet-distortableimage@0.21.9/dist/leaflet.distortableimage.css"
    />
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        height: 100vh;
        font-family: sans-serif;
      }
      #mapLeftContainer,
      #mapRightContainer {
        flex: 1;
        height: 100%;
        position: relative;
        border: 1px solid #ccc;
      }
      .map {
        width: 100%;
        height: 100%;
      }
      .map-title {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(255, 255, 255, 0.8);
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 16px;
        font-weight: bold;
        z-index: 1000;
      }
      #infoBox {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: white;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        max-width: 300px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      }
      .leaflet-image-layer {
        /* 픽셀화된 렌더링을 위한 CSS */
        image-rendering: -moz-crisp-edges; /* Firefox */
        image-rendering: -webkit-crisp-edges; /* Chrome, Safari (older) */
        image-rendering: pixelated; /* Chrome, Safari (newer), Edge, Opera */
        image-rendering: crisp-edges; /* General fallback / SVG */
      }

      /* Floating Button Styles */
      #floatingButtonsContainer {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 1001; /* map-title보다 위에 오도록 */
        display: flex;
        flex-direction: column;
        align-items: flex-end;
      }

      #sliderToggle {
        background-color: #007bff;
        color: white;
        border: none;
        padding: 10px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-bottom: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      #sliderToggle.collapsed {
        /* 특별한 스타일 변경이 필요하다면 여기에 추가 */
      }

      #buttonsGroup {
        display: flex;
        flex-direction: column;
        gap: 5px;
        transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
        max-height: 500px; /* 충분히 큰 값 */
        opacity: 1;
        overflow: hidden;
      }

      #buttonsGroup.collapsed {
        max-height: 0;
        opacity: 0;
      }

      .floating-sub {
        background-color: #f8f9fa;
        color: #333;
        border: 1px solid #ddd;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        text-align: center;
        font-size: 14px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        white-space: nowrap;
      }

      .floating-sub:hover {
        background-color: #e9ecef;
      }
    </style>
  </head>
  <body>
    <div id="mapLeftContainer">
      <div class="map-title">원본 수종 지도 (Origin Species)</div>
      <div id="mapLeft" class="map"></div>
    </div>
    <div id="mapRightContainer">
      <div class="map-title">Our 수종 지도 (Species)</div>
      <div id="mapRight" class="map"></div>
    </div>
    <div id="infoBox">지도 위를 클릭하여 정보를 확인하세요.</div>

    <!-- Floating Buttons HTML -->
    <div id="floatingButtonsContainer">
      <button id="sliderToggle">◀</button>
      <div id="buttonsGroup">
        <button class="floating-sub" data-area="jiri">지리산</button>
        <button class="floating-sub" data-area="sobaek">소백산</button>
        <button class="floating-sub" id="valViewToggleBtn">Val 보기 OFF</button>
        <button class="floating-sub" id="satelliteToggleBtn">
          위성 레이어 OFF
        </button>
        <!-- 필요시 버튼 추가 -->
      </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.sync@0.2.4/L.Map.Sync.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4leaflet/1.0.2/proj4leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/geotiff"></script>
    <script src="https://unpkg.com/leaflet-distortableimage@0.21.9/dist/leaflet.distortableimage.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.7.0/math.min.js"></script>
    <script src="utils.js"></script>

    <script>
      // multiMap.js에서 가져온 상수 및 전역 변수
      const utm52N = new L.Proj.CRS(
        "EPSG:32652",
        "+proj=utm +zone=52 +datum=WGS84 +units=m +no_defs",
        {
          resolutions: [
            8192, 4096, 2048, 1024, 512, 256, 128, 80, 64, 48, 32, 16, 8, 4, 2,
            1, 0.5,
          ],
        }
      );
      proj4.defs(
        "EPSG:32652",
        "+proj=utm +zone=52 +datum=WGS84 +units=m +no_defs"
      );

      // GeoJSON 파일 경로 (multiMap.js의 geojson_jiri, geojson_sobaek 변수 대체)
      const geojson_jiri_path = "./geojson/jiri_crop.geojson";
      const geojson_sobaek_path = "./geojson/sobaek_crop.geojson";

      // 수종 코드와 이름 매핑 (multiMap.js에는 없으므로 임의로 정의) -> utils.js 로 대체하므로 이 부분 삭제
      // const tree_color_map = {
      //     1: "신갈나무", 2: "소나무", 3: "일본잎갈나무", 4: "굴참나무", 5: "상수리나무",
      //     6: "리기다소나무", 7: "잣나무", 8: "물푸레나무", 9: "아까시나무", 10: "자작나무",
      //     11: "단풍나무", 12: "밤나무", 13: "현사시나무", 14: "기타활엽수", 15: "기타침엽수",
      //     // 필요에 따라 추가
      // };
      let infoBox = document.getElementById("infoBox");

      // --- Homography 관련 함수들 (multiMap.js에서 복사) ---
      function solveLinearSystem(A, b) {
        const n = A.length;
        for (let i = 0; i < n; i++) {
          A[i].push(b[i]);
        }
        for (let i = 0; i < n; i++) {
          let maxRow = i;
          for (let k = i + 1; k < n; k++) {
            if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
          }
          [A[i], A[maxRow]] = [A[maxRow], A[i]];
          if (Math.abs(A[i][i]) < 1e-12) return null;
          for (let k = i + 1; k < n + 1; k++) A[i][k] /= A[i][i];
          A[i][i] = 1;
          for (let k = 0; k < n; k++) {
            if (k !== i) {
              const factor = A[k][i];
              for (let j = i; j < n + 1; j++) A[k][j] -= factor * A[i][j];
            }
          }
        }
        const x = new Array(n);
        for (let i = 0; i < n; i++) x[i] = A[i][n];
        return x;
      }

      function computeHomographyMatrix(srcPoints, dstPoints) {
        if (srcPoints.length !== 4 || dstPoints.length !== 4)
          throw new Error("Need 4 corresponding points.");
        const A = [],
          b = [];
        for (let i = 0; i < 4; i++) {
          const [x_map, y_map] = srcPoints[i];
          const [x_img, y_img] = dstPoints[i];
          A.push([x_map, y_map, 1, 0, 0, 0, -x_img * x_map, -x_img * y_map]);
          b.push(x_img);
          A.push([0, 0, 0, x_map, y_map, 1, -y_img * x_map, -y_img * y_map]);
          b.push(y_img);
        }
        const h = solveLinearSystem(A, b);
        if (!h || h.length !== 8) {
          console.error("Homography solve failed.", h);
          return null;
        }
        return [
          [h[0], h[1], h[2]],
          [h[3], h[4], h[5]],
          [h[6], h[7], 1.0],
        ];
      }

      async function loadGeoJSON() {
        try {
          const [resp_jiri, resp_sobaek] = await Promise.all([
            fetch(geojson_jiri_path),
            fetch(geojson_sobaek_path),
          ]);
          const [data_jiri, data_sobaek] = await Promise.all([
            resp_jiri.json(),
            resp_sobaek.json(),
          ]);

          const utmToWgs84 = (coords) =>
            proj4("EPSG:32652", "EPSG:4326", [coords[0], coords[1]]);

          // GeoJSON 좌표는 [경도, 위도] 순서, Leaflet은 [위도, 경도] 순서
          const jiri_coords = data_jiri.features[0].geometry.coordinates[0]
            .map(utmToWgs84)
            .map((c) => L.latLng(c[1], c[0]));
          const sobaek_coords = data_sobaek.features[0].geometry.coordinates[0]
            .map(utmToWgs84)
            .map((c) => L.latLng(c[1], c[0]));

          // multiMap.js와 동일하게 jiriPoints를 1,2로 나눔
          const jiri_1Points = [
            jiri_coords[0],
            L.latLng(
              (jiri_coords[0].lat + jiri_coords[1].lat) / 2,
              (jiri_coords[0].lng + jiri_coords[1].lng) / 2
            ),
            L.latLng(
              (jiri_coords[2].lat + jiri_coords[3].lat) / 2,
              (jiri_coords[2].lng + jiri_coords[3].lng) / 2
            ),
            jiri_coords[3],
            jiri_coords[0],
          ]; // 닫힌 폴리곤을 위해 시작점 추가
          const jiri_2Points = [
            L.latLng(
              (jiri_coords[0].lat + jiri_coords[1].lat) / 2,
              (jiri_coords[0].lng + jiri_coords[1].lng) / 2
            ),
            jiri_coords[1],
            jiri_coords[2],
            L.latLng(
              (jiri_coords[2].lat + jiri_coords[3].lat) / 2,
              (jiri_coords[2].lng + jiri_coords[3].lng) / 2
            ),
            L.latLng(
              (jiri_coords[0].lat + jiri_coords[1].lat) / 2,
              (jiri_coords[0].lng + jiri_coords[1].lng) / 2
            ),
          ];

          return {
            jiri_1: jiri_1Points,
            jiri_2: jiri_2Points,
            sobaek: sobaek_coords,
          };
        } catch (error) {
          console.error("GeoJSON 로드 중 오류 발생:", error);
          infoBox.innerHTML = "GeoJSON 로드 실패: " + error.message;
          return null;
        }
      }

      class CompareMapInstance {
        constructor(mapId, tifBaseFolder, geoJsonData, mapTitle) {
          this.mapId = mapId;
          this.tifBaseFolder = tifBaseFolder; // 예: './tif/species/origin' 또는 './tif/species'
          this.geoJsonData = geoJsonData;
          this.mapTitle = mapTitle; // 지도 제목 (정보 표시에 사용)
          this.map = null;

          this.imageUrls = { jiri_1: null, jiri_2: null, sobaek: null };
          this.imageRasters = { jiri_1: null, jiri_2: null, sobaek: null };
          this.imageBounds = { jiri_1: null, jiri_2: null, sobaek: null };
          this.jiri_1_tifLayer = null;
          this.jiri_2_tifLayer = null;
          this.sobaek_tifLayer = null;
          this.homographyMatrices = {
            jiri_1: null,
            jiri_2: null,
            sobaek: null,
          };
          this.invHomographyMatrices = {
            jiri_1: null,
            jiri_2: null,
            sobaek: null,
          };

          this.imagePixelWidth = 3600; // TIF 이미지 픽셀 너비 (가정)
          this.imagePixelHeight = 3600; // TIF 이미지 픽셀 높이 (가정)

          this.currentMarker = null;
          this.initMap();

          this.valViewGridLayer = null; // Val 보기 그리드 레이어를 저장할 변수
          this.satelliteLayer = null; // 위성 타일 레이어를 저장할 변수
          this.isSatelliteLayerActive = false; // 위성 레이어 활성 상태
        }

        initMap() {
          this.map = L.map(this.mapId, {
            center: [36.5, 128.0], // 한반도 중앙 부근
            zoom: 7,
            maxZoom: 20,
            zoomControl: true,
            attributionControl: false,
          });
          L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19,
          }).addTo(this.map);
          this.setImageBoundsFromGeoJson();
        }

        setImageBoundsFromGeoJson() {
          // multiMap.js의 setImageBounds 로직과 유사하게 설정
          // DistortableImageOverlay는 corners를 TL, TR, BL, BR 순서로 받음
          // GeoJSON 데이터의 점 순서 (보통 외곽선 따라 순차적)를 확인하고 맞게 매핑
          // jiri_1Points, jiri_2Points, sobaekPoints는 Leaflet LatLng 객체의 배열
          // 예: geoJsonData.jiri_1 = [pt0, pt1, pt2, pt3, pt0_again] -> corners: [pt3, pt2, pt0, pt1] (순서 확인 필요!)

          // multiMap.js에서 사용된 imageBounds 순서 (좌하단, 우하단, 좌상단, 우상단)
          // L.DistortableImageOverlay는 좌상단, 우상단, 좌하단, 우하단 순서 (TL, TR, BL, BR)
          // geoJsonData.jiri_1[3], geoJsonData.jiri_1[2], geoJsonData.jiri_1[0], geoJsonData.jiri_1[1]
          // 이 순서는 DistortableImageOverlay의 corners 옵션에 직접 사용됨
          this.imageBounds.jiri_1 = [
            this.geoJsonData.jiri_1[3],
            this.geoJsonData.jiri_1[2],
            this.geoJsonData.jiri_1[0],
            this.geoJsonData.jiri_1[1],
          ];
          this.imageBounds.jiri_2 = [
            this.geoJsonData.jiri_2[3],
            this.geoJsonData.jiri_2[2],
            this.geoJsonData.jiri_2[0],
            this.geoJsonData.jiri_2[1],
          ];
          // 소백산은 점이 5개 (마지막은 시작과 동일), 실제 사용하는 점은 4개
          const sobaekPts = this.geoJsonData.sobaek.slice(0, 4); // 마지막 중복점 제외
          this.imageBounds.sobaek = [
            sobaekPts[3],
            sobaekPts[2],
            sobaekPts[0],
            sobaekPts[1],
          ];
        }

        async loadAndDrawTifs() {
          const tifRegions = ["jiri_1", "jiri_2", "sobaek"];
          for (const region of tifRegions) {
            const tifUrl = `${this.tifBaseFolder}/${region}.tif`;
            try {
              // imageUrls와 imageRasters는 최초 한 번만 로드
              if (!this.imageUrls[region]) {
                const imageData = await this.makeImageDataFromTif(tifUrl);
                this.imageUrls[region] = imageData.url;
                this.imageRasters[region] = imageData.raster; // Homography 계산 및 픽셀 값 접근에 필요
              }

              // Homography 계산 (최초 한 번 또는 필요시)
              // 이 부분은 imageUrls, imageBounds가 설정된 후, 그리고 imageRasters가 로드된 후에 실행되어야 함.
              // DistortableImageOverlay를 지도에 추가하기 전에 계산 가능.
              // 여기서는 this.imageBounds[region]을 사용. (주의: _drawTifRegion으로 옮겨서 매번 레이어에서 getCorners 할 수도 있음)
              if (
                this.imageBounds[region] &&
                !this.homographyMatrices[region]
              ) {
                const srcPoints = this.imageBounds[region].map((p) => [
                  p.lng,
                  p.lat,
                ]);
                // 참고: this.imageBounds는 TL, TR, BL, BR 순서가 아니므로, computeHomographyMatrix에 맞게 조정 필요
                // computeHomographyMatrix는 [lng, lat] srcPoints와 [col, row] dstPoints를 기대
                // L.DistortableImageOverlay의 corners 옵션은 TL, TR, BL, BR (좌상, 우상, 좌하, 우하)
                // this.imageBounds는 현재 [geoJsonData.jiri_1[3], geoJsonData.jiri_1[2], geoJsonData.jiri_1[0], geoJsonData.jiri_1[1]]
                // 이것이 TL, TR, BL, BR 순서에 해당하는지 확인하고, 아니라면 computeHomographyMatrix의 srcPoints를 올바르게 구성해야 함.
                // 현재 imageBounds 순서 (this.geoJsonData.jiri_1[3], this.geoJsonData.jiri_1[2], this.geoJsonData.jiri_1[0], this.geoJsonData.jiri_1[1])
                // 를 mapGeoCorners = [TL, TR, BL, BR] 와 동일하게 취급하려면,
                // TL = this.imageBounds[region][0], TR = this.imageBounds[region][1], BL = this.imageBounds[region][2], BR = this.imageBounds[region][3] (예시, 실제 매핑 확인)
                // computeHomographyMatrix의 srcPoints는 [ [TL.lng, TL.lat], [TR.lng, TR.lat], [BL.lng, BL.lat], [BR.lng, BR.lat] ] 순서여야 함 (일반적)
                // 기존에는 레이어에서 getCorners()를 사용했음 (이것이 더 안전)
                // 지금은 레이어 추가 전에 Homography를 계산하려고 하므로, imageBounds 순서가 매우 중요.

                // 일단 기존 방식대로 레이어를 먼저 그리고 Homography를 계산하는 것으로 유지하거나,
                // imageBounds 순서를 명확히 하여 Homography 계산 로직을 여기에 넣어야 함.
                // 여기서는 _drawTifRegion 호출 시 레이어가 그려지고, 그 후 Homography를 계산하도록 순서를 조정하는 것이 안전할 수 있음.
              }

              // 초기 TIF 그리기
              this._drawTifRegion(region);

              // Homography 계산 (레이어가 그려진 후)
              const currentTifLayer =
                region === "jiri_1"
                  ? this.jiri_1_tifLayer
                  : region === "jiri_2"
                  ? this.jiri_2_tifLayer
                  : this.sobaek_tifLayer;
              if (currentTifLayer && !this.homographyMatrices[region]) {
                const mapGeoCorners = currentTifLayer.getCorners();
                const srcPointsForH = mapGeoCorners.map((p) => [p.lng, p.lat]);
                const dstPointsForH = [
                  [0, 0],
                  [this.imagePixelWidth, 0],
                  [0, this.imagePixelHeight],
                  [this.imagePixelWidth, this.imagePixelHeight],
                ];
                this.homographyMatrices[region] = computeHomographyMatrix(
                  srcPointsForH,
                  dstPointsForH
                );
                if (this.homographyMatrices[region]) {
                  try {
                    this.invHomographyMatrices[region] = math.inv(
                      this.homographyMatrices[region]
                    );
                  } catch (e) {
                    console.error(
                      `Error inverting homography for ${region} on ${this.mapId}: ${e}`
                    );
                    this.invHomographyMatrices[region] = null;
                  }
                } else {
                  console.error(
                    `Homography matrix calculation failed for ${region} on ${this.mapId}.`
                  );
                }
              }
            } catch (error) {
              console.error(
                `Error loading TIF for ${region} on ${this.mapId}: ${tifUrl}`,
                error
              );
              infoBox.innerHTML += `<br/>${this.mapTitle} ${region} TIF 로드 실패.`;
            }
          }
        }

        // TIF 파일을 읽어 Canvas를 통해 이미지 URL과 래스터 데이터를 생성하는 함수
        async makeImageDataFromTif(tifPath) {
          const response = await fetch(tifPath);
          if (!response.ok)
            throw new Error(
              `Failed to fetch TIF: ${response.status} ${tifPath}`
            );
          const arrayBuffer = await response.arrayBuffer();
          const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
          const image = await tiff.getImage();
          const rasters = await image.readRasters(); // 첫 번째 밴드만 사용 가정
          const width = image.getWidth();
          const height = image.getHeight();

          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          ctx.imageSmoothingEnabled = false; // 픽셀 선명하게

          const imageData = ctx.createImageData(width, height);
          const data = imageData.data;
          const tifData = rasters[0]; // 첫 번째 밴드

          // 수종 데이터에 대한 시각화: tree_color_map을 기반으로 색상 부여 또는 단순 회색조
          // 여기서는 간단히 값 자체를 회색조로 표시 (0~255 범위로 정규화는 생략, 값이 작을 수 있으므로)
          // 실제 수종 값은 보통 작은 정수이므로, 이를 색상으로 매핑하는 로직이 필요할 수 있음.
          // 여기서는 값이 없거나 (-9999 등) 너무 큰 경우를 제외하고 표시
          const noDataValue1 = -9999; // 예시 NoData 값
          const noDataValue2 = image.getGDALNoData(); // GeoTIFF 헤더의 NoData 값

          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const i = y * width + x;
              const pixelValue = tifData[i];
              let r = 0,
                g = 0,
                b = 0,
                a = 0,
                color = null;

              if (
                pixelValue !== noDataValue1 &&
                pixelValue !== noDataValue2 &&
                pixelValue !== null &&
                pixelValue !== undefined
              ) {
                // 수종 값에 따라 색상 매핑 (여기서는 단순화)
                // tree_color_map에 있는 값이라면 해당 색상, 아니면 기본색
                const hexColor = pred_palette[pixelValue]; // pixelValue에 해당하는 16진수 색상 문자열을 가져옴

                if (hexColor) {
                  // 16진수 색상 문자열을 RGBA로 변환
                  //r = (pixelValue * 30) % 255;
                  //g = (pixelValue * 50) % 255;
                  //b = (pixelValue * 70) % 255;
                  const hex = hexColor.replace("#", "");
                  r = parseInt(hex.substring(0, 2), 16);
                  g = parseInt(hex.substring(2, 4), 16);
                  b = parseInt(hex.substring(4, 6), 16);
                  a = 255; // 불투명
                } else {
                  // pred_palette에 없는 값은 투명하게 처리하거나 기본값 처리
                  r = 0;
                  g = 0;
                  b = 0;
                  a = 150; // 투명
                }
              }

              const dataIndex = i * 4;
              data[dataIndex] = r;
              data[dataIndex + 1] = g;
              data[dataIndex + 2] = b;
              data[dataIndex + 3] = a;
            }
          }
          ctx.putImageData(imageData, 0, 0);
          return { url: canvas.toDataURL(), raster: rasters }; // rasters[0]만 반환해도 됨
        }

        determineRegionForLatLng(latlng) {
          // multiMap.js의 determineRegionForLatLng과 유사하게, LatLng이 어떤 TIF 영역에 속하는지 판단
          // 여기서는 this.imageBounds (DistortableImageOverlay의 corners)를 사용.
          // L.latLngBounds로 변환하여 contains 메소드 사용.
          // DistortableImageOverlay의 getBounds()를 사용할 수도 있음 (레이어가 그려진 후)
          if (
            this.jiri_1_tifLayer &&
            this.jiri_1_tifLayer.getBounds().contains(latlng)
          )
            return "jiri_1";
          if (
            this.jiri_2_tifLayer &&
            this.jiri_2_tifLayer.getBounds().contains(latlng)
          )
            return "jiri_2";
          if (
            this.sobaek_tifLayer &&
            this.sobaek_tifLayer.getBounds().contains(latlng)
          )
            return "sobaek";

          // Fallback if layers not fully drawn or for initial check based on raw bounds
          // Note: this.imageBounds are corners, need to convert to L.latLngBounds
          const jiri1Bounds = L.latLngBounds(this.imageBounds.jiri_1);
          if (jiri1Bounds && jiri1Bounds.contains(latlng)) return "jiri_1";
          const jiri2Bounds = L.latLngBounds(this.imageBounds.jiri_2);
          if (jiri2Bounds && jiri2Bounds.contains(latlng)) return "jiri_2";
          const sobaekBounds = L.latLngBounds(this.imageBounds.sobaek);
          if (sobaekBounds && sobaekBounds.contains(latlng)) return "sobaek";

          return null;
        }

        async getPixelValueAtLatLng(latlng) {
          const targetRegion = this.determineRegionForLatLng(latlng);
          if (!targetRegion) return { value: null, region: null };

          const homography = this.homographyMatrices[targetRegion];
          const rasterData = this.imageRasters[targetRegion]
            ? this.imageRasters[targetRegion][0]
            : null;

          if (!homography || !rasterData) {
            console.warn(
              `Homography or raster data not available for ${targetRegion} on map ${this.mapId}.`
            );
            return { value: null, region: targetRegion };
          }

          try {
            const P_map = [latlng.lng, latlng.lat, 1];
            const P_img_h = [
              homography[0][0] * P_map[0] +
                homography[0][1] * P_map[1] +
                homography[0][2] * P_map[2],
              homography[1][0] * P_map[0] +
                homography[1][1] * P_map[1] +
                homography[1][2] * P_map[2],
              homography[2][0] * P_map[0] +
                homography[2][1] * P_map[1] +
                homography[2][2] * P_map[2],
            ];

            if (Math.abs(P_img_h[2]) < 1e-9)
              return { value: null, region: targetRegion };

            const u_img = P_img_h[0] / P_img_h[2]; // col (X)
            const v_img = P_img_h[1] / P_img_h[2]; // row (Y)
            const colX = Math.floor(u_img);
            const rowY = Math.floor(v_img);

            if (
              colX >= 0 &&
              colX < this.imagePixelWidth &&
              rowY >= 0 &&
              rowY < this.imagePixelHeight
            ) {
              const pixelValue = rasterData[rowY * this.imagePixelWidth + colX];
              return {
                value: pixelValue,
                region: targetRegion,
                latlng: latlng,
              };
            }
            return { value: null, region: targetRegion };
          } catch (error) {
            console.error(
              `Error getting pixel value for ${this.mapId} at ${targetRegion}:`,
              error
            );
            return { value: null, region: targetRegion };
          }
        }

        updateMarkerAndInfo(data) {
          // data: {value, region, latlng, mapTitle}
          if (this.currentMarker) {
            this.map.removeLayer(this.currentMarker);
            this.currentMarker = null;
          }

          let popupContent = "";

          if (data.value !== null && data.latlng) {
            const speciesName =
              tree_color_map[data.value] || `알 수 없음 (코드: ${data.value})`;
            popupContent = `<b>${data.mapTitle}</b><br>지역: ${
              data.region || "N/A"
            }<br>수종: ${speciesName}<br>좌표: ${data.latlng.lat.toFixed(
              5
            )}, ${data.latlng.lng.toFixed(5)}`;

            this.currentMarker = L.marker(data.latlng)
              .bindPopup(popupContent)
              .addTo(this.map)
              .openPopup();
          } else if (data.latlng) {
            // 값은 없지만 클릭 위치는 있을 때
            popupContent = `<b>${data.mapTitle}</b><br>지역: ${
              data.region || "N/A"
            } <br>해당 위치에 데이터가 없습니다.<br>좌표: ${data.latlng.lat.toFixed(
              5
            )}, ${data.latlng.lng.toFixed(5)}`;
          }
          return popupContent; // infoBox 직접 업데이트 대신 팝업 내용을 반환
        }

        // Val 보기 기능을 토글하는 메서드
        toggleValView(isOn) {
          if (isOn) {
            // Val 보기가 켜졌을 때의 로직
            if (!this.valViewGridLayer) {
              this.valViewGridLayer = L.featureGroup().addTo(this.map);
            } else {
              this.valViewGridLayer.addTo(this.map); // 이미 있다면 다시 추가
            }
            this.drawValViewGrid();
          } else {
            // Val 보기가 꺼졌을 때의 로직
            if (this.valViewGridLayer) {
              this.map.removeLayer(this.valViewGridLayer);
              this.valViewGridLayer.clearLayers(); // 그룹 내 레이어 모두 제거
            }
          }
        }

        // 위성 레이어를 토글하는 메서드
        toggleSatelliteLayer(isOn, isValViewCurrentlyOn) {
          this.isSatelliteLayerActive = isOn;
          if (isOn) {
            if (!this.satelliteLayer) {
              this.satelliteLayer = L.tileLayer(
                "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
                {
                  attribution:
                    "Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA FSA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",
                  maxZoom: 18,
                }
              );
            }
            this.satelliteLayer.addTo(this.map);

            // TIF 레이어 숨기기
            this._removeTifRegion("jiri_1");
            this._removeTifRegion("jiri_2");
            this._removeTifRegion("sobaek");

            // ValView 그리드는 (Val 보기가 켜져있었다면) 위성 위로 가져오기
            if (isValViewCurrentlyOn && this.valViewGridLayer) {
              if (!this.map.hasLayer(this.valViewGridLayer)) {
                this.valViewGridLayer.addTo(this.map);
              }
              this.valViewGridLayer.bringToFront();
            }
          } else {
            // 위성 레이어 OFF
            if (this.satelliteLayer && this.map.hasLayer(this.satelliteLayer)) {
              this.map.removeLayer(this.satelliteLayer);
            }
            console.log("위성 레이어 OFF");
            // TIF 레이어 다시 보여주기
            this._drawTifRegion("jiri_1");
            this._drawTifRegion("jiri_2");
            this._drawTifRegion("sobaek");

            // ValView 그리드도 (Val 보기가 켜져있었다면) TIF 위로 가져오기
            if (isValViewCurrentlyOn && this.valViewGridLayer) {
              if (!this.map.hasLayer(this.valViewGridLayer)) {
                this.valViewGridLayer.addTo(this.map);
              }
              this.valViewGridLayer.bringToFront();
            }
          }
        }

        // Val 보기 그리드를 그리는 메서드
        drawValViewGrid() {
          if (!this.valViewGridLayer) return;
          this.valViewGridLayer.clearLayers(); // 기존 그리드 제거

          const regionsToHighlight = {
            jiri_1: [
              [2, 5],
              [3, 9],
            ],
            jiri_2: [
              [2, 2],
              [5, 9],
            ],
            sobaek: [
              [6, 0],
              [7, 0],
            ],
          };

          const gridSize = 10; // 10x10 그리드
          const cellPixelWidth = this.imagePixelWidth / gridSize;
          const cellPixelHeight = this.imagePixelHeight / gridSize;

          for (const regionKey in this.invHomographyMatrices) {
            if (
              !this.invHomographyMatrices[regionKey] ||
              !regionsToHighlight[regionKey]
            )
              continue;

            const invH = this.invHomographyMatrices[regionKey];
            const highlightCellsForRegion = regionsToHighlight[regionKey];

            for (let r = 0; r < gridSize; r++) {
              // row
              for (let c = 0; c < gridSize; c++) {
                // col
                // 셀의 픽셀 좌표 (좌상단, 우하단)
                const topLeftPixel = {
                  x: c * cellPixelWidth,
                  y: r * cellPixelHeight,
                };
                const topRightPixel = {
                  x: (c + 1) * cellPixelWidth,
                  y: r * cellPixelHeight,
                };
                const bottomLeftPixel = {
                  x: c * cellPixelWidth,
                  y: (r + 1) * cellPixelHeight,
                };
                const bottomRightPixel = {
                  x: (c + 1) * cellPixelWidth,
                  y: (r + 1) * cellPixelHeight,
                };

                // 픽셀 좌표를 위경도로 변환하는 함수 (이 함수는 단순화된 버전이며, 실제로는 math.js 행렬 곱셈 필요)
                // 호모그래피 변환: P_map_h = H_inv * P_img_h
                const transform = (pixel) => {
                  const pImg = [pixel.x, pixel.y, 1];
                  const pMapH = [
                    invH[0][0] * pImg[0] +
                      invH[0][1] * pImg[1] +
                      invH[0][2] * pImg[2],
                    invH[1][0] * pImg[0] +
                      invH[1][1] * pImg[1] +
                      invH[1][2] * pImg[2],
                    invH[2][0] * pImg[0] +
                      invH[2][1] * pImg[1] +
                      invH[2][2] * pImg[2],
                  ];
                  if (Math.abs(pMapH[2]) < 1e-9) return null; // 0으로 나누기 방지
                  return L.latLng(pMapH[1] / pMapH[2], pMapH[0] / pMapH[2]); // lat, lng 순서
                };

                const topLeftLatLng = transform(topLeftPixel);
                const topRightLatLng = transform(topRightPixel);
                const bottomLeftLatLng = transform(bottomLeftPixel);
                const bottomRightLatLng = transform(bottomRightPixel);

                if (
                  topLeftLatLng &&
                  topRightLatLng &&
                  bottomLeftLatLng &&
                  bottomRightLatLng
                ) {
                  // const cellBounds = L.latLngBounds(topLeftLatLng, bottomRightLatLng);
                  // L.rectangle은 일반적으로 bounds 또는 [LatLng, LatLng, ...] 형태의 배열을 받음
                  // 여기서는 LatLng 배열로 네 꼭짓점을 전달 (순서는 Leaflet 문서 참고)
                  // DistortableImageOverlay와 달리 일반 rectangle은 꼭짓점 순서가 덜 민감할 수 있으나, 일반적으로 좌상-우하 또는 폴리곤 배열을 사용.
                  // 간단하게 bounds로 생성.

                  // L.polygon으로 변경하고, 꼭짓점 순서에 유의 (예: 시계방향)
                  const polygonCoords = [
                    topLeftLatLng,
                    topRightLatLng,
                    bottomRightLatLng,
                    bottomLeftLatLng,
                  ];

                  const isHighlighted = highlightCellsForRegion.some(
                    (cell) => cell[0] === r && cell[1] === c
                  );

                  // const rect = L.rectangle(cellBounds, {
                  const polygon = L.polygon(polygonCoords, {
                    // L.rectangle 대신 L.polygon 사용
                    color: isHighlighted ? "#ff0000" : "#000000", // 빨강 또는 검정 테두리
                    weight: isHighlighted ? 1 : 1,
                    fillColor: isHighlighted ? "#ff0000" : "#555555",
                    fillOpacity: isHighlighted ? 0.0 : 0.6, // 하이라이트는 덜 투명하게, 나머지는 더 어둡게
                  });
                  // this.valViewGridLayer.addLayer(rect);
                  this.valViewGridLayer.addLayer(polygon); // polygon으로 변경
                }
              }
            }
          }
        }

        // 특정 TIF 지역을 지도에 그리는 내부 메서드
        _drawTifRegion(regionKey) {
          if (this.imageUrls[regionKey] && this.imageBounds[regionKey]) {
            // 기존 레이어가 있다면 먼저 제거
            this._removeTifRegion(regionKey);

            const newTifLayer = L.distortableImageOverlay(
              this.imageUrls[regionKey],
              {
                corners: this.imageBounds[regionKey],
                opacity: 0.7, // 기본 투명도
                actions: [], // 편집 비활성화
              }
            ).addTo(this.map);

            if (regionKey === "jiri_1") this.jiri_1_tifLayer = newTifLayer;
            else if (regionKey === "jiri_2") this.jiri_2_tifLayer = newTifLayer;
            else if (regionKey === "sobaek") this.sobaek_tifLayer = newTifLayer;

            // Homography는 imageRasters를 사용하므로, 최초 로드 시 이미 계산되어 있어야 함.
            // 만약 Homography도 여기서 다시 계산해야 한다면, imageRasters가 필요함.
            // 현재 구조에서는 loadAndDrawTifs에서 한 번만 계산하고 imageRasters를 보존한다고 가정.
          }
        }

        // 특정 TIF 지역을 지도에서 제거하는 내부 메서드
        _removeTifRegion(regionKey) {
          let layerToRemove = null;
          if (regionKey === "jiri_1") layerToRemove = this.jiri_1_tifLayer;
          else if (regionKey === "jiri_2") layerToRemove = this.jiri_2_tifLayer;
          else if (regionKey === "sobaek") layerToRemove = this.sobaek_tifLayer;

          if (layerToRemove && this.map.hasLayer(layerToRemove)) {
            this.map.removeLayer(layerToRemove);
          }

          // 해당 속성 null로 설정
          if (regionKey === "jiri_1") this.jiri_1_tifLayer = null;
          else if (regionKey === "jiri_2") this.jiri_2_tifLayer = null;
          else if (regionKey === "sobaek") this.sobaek_tifLayer = null;
        }
      }

      async function initializeCompareMaps() {
        const geoJsonData = await loadGeoJSON();
        if (!geoJsonData) {
          infoBox.textContent =
            "GeoJSON 데이터 로드 실패. 지도를 초기화할 수 없습니다.";
          return;
        }

        const mapLeftInstance = new CompareMapInstance(
          "mapLeft",
          "./tif/species/origin",
          geoJsonData,
          "원본 수종 지도"
        );
        const mapRightInstance = new CompareMapInstance(
          "mapRight",
          "./tif/species",
          geoJsonData,
          "Our 수종 지도"
        );

        await Promise.all([
          mapLeftInstance.loadAndDrawTifs(),
          mapRightInstance.loadAndDrawTifs(),
        ]);

        // 지도 동기화
        console.log("지도 동기화", mapLeftInstance.map, mapRightInstance.map);
        mapLeftInstance.map.sync(mapRightInstance.map);
        mapRightInstance.map.sync(mapLeftInstance.map);

        // 공통 맵 클릭 이벤트 핸들러
        function onMapClick(e, clickedInstance) {
          // clickedInstance를 받아 어떤 맵이 클릭되었는지 알 수 있도록 함
          Promise.all([
            mapLeftInstance.getPixelValueAtLatLng(e.latlng),
            mapRightInstance.getPixelValueAtLatLng(e.latlng),
          ]).then(([dataLeft, dataRight]) => {
            let infoBoxHTML = "";

            // 왼쪽 지도 정보 업데이트 및 마커 생성
            const popupLeft = mapLeftInstance.updateMarkerAndInfo({
              ...dataLeft,
              mapTitle: mapLeftInstance.mapTitle,
              latlng: e.latlng,
            });
            if (popupLeft) infoBoxHTML += popupLeft;

            // 오른쪽 지도 정보 업데이트 및 마커 생성
            const popupRight = mapRightInstance.updateMarkerAndInfo({
              ...dataRight,
              mapTitle: mapRightInstance.mapTitle,
              latlng: e.latlng,
            });

            if (popupRight) {
              if (infoBoxHTML) infoBoxHTML += "<hr>"; // 구분선 추가
              infoBoxHTML += popupRight;
            }

            // infoBox 업데이트
            if (infoBoxHTML) {
              infoBox.innerHTML = infoBoxHTML;
            } else {
              // 양쪽 다 정보가 없는 경우
              infoBox.innerHTML = `해당 위치(${e.latlng.lat.toFixed(
                5
              )}, ${e.latlng.lng.toFixed(5)})에 데이터가 없습니다.`;
            }

            // 클릭된 인스턴스의 팝업을 강제로 열어줌 (다른 맵 팝업에 가려지는 것 방지)
            if (
              clickedInstance === mapLeftInstance &&
              mapLeftInstance.currentMarker
            ) {
              mapLeftInstance.currentMarker.openPopup();
            } else if (
              clickedInstance === mapRightInstance &&
              mapRightInstance.currentMarker
            ) {
              mapRightInstance.currentMarker.openPopup();
            }
          });
        }

        mapLeftInstance.map.on("click", (e) => onMapClick(e, mapLeftInstance));
        mapRightInstance.map.on("click", (e) =>
          onMapClick(e, mapRightInstance)
        );

        // 초기 뷰 설정 (예: 지리산 또는 소백산 영역에 맞춤)
        const initialBounds = L.latLngBounds(geoJsonData.jiri_1)
          .extend(geoJsonData.jiri_2)
          .extend(geoJsonData.sobaek);
        mapLeftInstance.map.fitBounds(initialBounds);
        // mapRightInstance.map.fitBounds(initialBounds); // Sync로 인해 자동으로 맞춰짐

        infoBox.textContent =
          "지도가 준비되었습니다. 클릭하여 수종 정보를 확인하세요.";

        // --- Floating Buttons JavaScript --- (initializeCompareMaps 함수 내부에 추가)
        const sliderToggle = document.getElementById("sliderToggle");
        const buttonsGroup = document.getElementById("buttonsGroup");
        let isSliderOpen = true; // 초기 상태: 버튼 그룹 보임

        sliderToggle.addEventListener("click", () => {
          isSliderOpen = !isSliderOpen;
          buttonsGroup.classList.toggle("collapsed", !isSliderOpen);
          sliderToggle.textContent = isSliderOpen ? "◀" : "▶";
        });

        const floatingSubButtons = document.querySelectorAll(".floating-sub");
        floatingSubButtons.forEach((button) => {
          button.addEventListener("click", () => {
            const area = button.getAttribute("data-area");
            let targetBounds;

            if (area === "jiri") {
              if (geoJsonData && geoJsonData.jiri_1 && geoJsonData.jiri_2) {
                targetBounds = L.latLngBounds(geoJsonData.jiri_1).extend(
                  geoJsonData.jiri_2
                );
              }
            } else if (area === "sobaek") {
              if (geoJsonData && geoJsonData.sobaek) {
                targetBounds = L.latLngBounds(geoJsonData.sobaek);
              }
            }

            if (targetBounds && mapLeftInstance && mapLeftInstance.map) {
              mapLeftInstance.map.fitBounds(targetBounds, {
                animate: true,
                duration: 0.7,
              });
            }
          });
        });

        // "Val 보기" 버튼 토글 기능
        const valViewToggleBtn = document.getElementById("valViewToggleBtn");
        let isValViewOn = false; // 초기 상태: OFF

        valViewToggleBtn.addEventListener("click", () => {
          isValViewOn = !isValViewOn;
          valViewToggleBtn.textContent = isValViewOn
            ? "Val 보기 ON"
            : "Val 보기 OFF";

          if (mapLeftInstance) {
            if (!mapLeftInstance.isSatelliteLayerActive) {
              // 위성 OFF 상태
              mapLeftInstance.toggleValView(isValViewOn);
            } else {
              // 위성 ON 상태
              if (isValViewOn) {
                if (!mapLeftInstance.valViewGridLayer) {
                  mapLeftInstance.valViewGridLayer = L.featureGroup();
                }
                mapLeftInstance.valViewGridLayer.addTo(mapLeftInstance.map); // 그룹 먼저 추가
                mapLeftInstance.drawValViewGrid(); // 내용 채우기
                mapLeftInstance.valViewGridLayer.bringToFront();
              } else {
                if (
                  mapLeftInstance.valViewGridLayer &&
                  mapLeftInstance.map.hasLayer(mapLeftInstance.valViewGridLayer)
                ) {
                  mapLeftInstance.map.removeLayer(
                    mapLeftInstance.valViewGridLayer
                  );
                  mapLeftInstance.valViewGridLayer.clearLayers();
                }
              }
            }
          }
          if (mapRightInstance) {
            if (!mapRightInstance.isSatelliteLayerActive) {
              // 위성 OFF 상태
              mapRightInstance.toggleValView(isValViewOn);
            } else {
              // 위성 ON 상태
              if (isValViewOn) {
                if (!mapRightInstance.valViewGridLayer) {
                  mapRightInstance.valViewGridLayer = L.featureGroup();
                }
                mapRightInstance.valViewGridLayer.addTo(mapRightInstance.map); // 그룹 먼저 추가
                mapRightInstance.drawValViewGrid(); // 내용 채우기
                mapRightInstance.valViewGridLayer.bringToFront();
              } else {
                if (
                  mapRightInstance.valViewGridLayer &&
                  mapRightInstance.map.hasLayer(
                    mapRightInstance.valViewGridLayer
                  )
                ) {
                  mapRightInstance.map.removeLayer(
                    mapRightInstance.valViewGridLayer
                  );
                  mapRightInstance.valViewGridLayer.clearLayers();
                }
              }
            }
          }
        });

        // "위성 레이어" 버튼 토글 기능
        const satelliteToggleBtn =
          document.getElementById("satelliteToggleBtn");
        let isSatelliteLayerOn = false; // 초기 상태: OFF

        satelliteToggleBtn.addEventListener("click", () => {
          isSatelliteLayerOn = !isSatelliteLayerOn;
          satelliteToggleBtn.textContent = isSatelliteLayerOn
            ? "위성 레이어 ON"
            : "위성 레이어 OFF";

          console.log(
            "위성 토글: Left 호출 전, isSatelliteLayerOn:",
            isSatelliteLayerOn,
            "isValViewOn:",
            isValViewOn
          );
          if (mapLeftInstance) {
            mapLeftInstance.toggleSatelliteLayer(
              isSatelliteLayerOn,
              isValViewOn
            );
          }
          console.log(
            "위성 토글: Right 호출 전, mapRightInstance 존재 여부:",
            !!mapRightInstance
          );
          if (mapRightInstance) {
            mapRightInstance.toggleSatelliteLayer(
              isSatelliteLayerOn,
              isValViewOn
            );
            console.log("위성 토글: Right 호출 완료");
          } else {
            console.error("mapRightInstance가 존재하지 않습니다!");
          }
        });

        // --- End of Floating Buttons JavaScript ---
      }

      initializeCompareMaps();
    </script>
  </body>
</html>
